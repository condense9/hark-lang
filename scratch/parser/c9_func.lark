// ruby-doc.org/docs/ruby-doc-bundle/Manual/man-1.4/yacc.html
//
// Kinda like Ruby.
//
// Considerations
// - paradigm (functional)
// - assignment... ??
// - scope
// - easy of implementation
//
// Features
// - easy FFI (import a Python module and call functions in it)
// - ? lambdas (objects that can be evaluated with arguments substituted in)
// - function definition (named lambda expressions)
// - handle JSON-like data
// - ? closures (lambdas that capture lexical scope)
//
// Syntax must support
// - function definition
// - value binding (in a given scope, this is just an anonymous lambda application)
// - ? async/await
//
// Design decisions
// - variables are immutable (no reassignment, so line-order is irrelevant)
// - functions are pure
// - side-effects achieved through foreign calls (or built-in specials)


// https ://www.haskell.org/onlinereport/syntax-iso.html
// https ://wiki.haskell.org/Foreign_Function_Interface

start : service

?service     : "service" service_name [_NEWLINE body]
             | body
service_name : IDENTIFIER
?body        : [topdecl] (_NEWLINE topdecl)*
topdecl      : decl
             | import

import      : "import" import_name
import_name : IDENTIFIER

decl     : def_lhs "=" def_rhs
def_rhs  : expression
def_lhs  : def_name [binding*]
def_name : IDENTIFIER
binding  : IDENTIFIER

?expression : exp_0

// homepage.divms.uiowa.edu/~fleck/HaskellexprBNF.pdf
// www.haskell.org/onlinereport/decls.html#fixity
//
// generator :
// exp.0     : nexp.0 | lexp.0 | rexp.0
// nexp.0    : exp.1 [qop_n.0 exp.1]
// lexp.0    : (lexp.0 | exp.1) qop_l.0 | exp.1
// rexp.0    : exp.1 qop_r.0 (rexp.0 | exp.1)

?exp_0 : exp_1 [qop_n_0 exp_1]

?exp_1  : exp_2 | lexp_1
?lexp_1 : (lexp_1 | exp_2) qop_l_1 exp_2

?exp_2  : exp_3 | lexp_2
?lexp_2 : (lexp_2 | exp_3) qop_l_2 exp_3

qop_n_0    : "<"  -> lt
           | ">"  -> gt
           | "==" -> eq
qop_l_1    : "+"  -> add
           | "-"  -> subtract
qop_l_2    : "*"  -> mutiply
           | "/"  -> divide
// qop_r_9 : "."  -> compose


?exp_3 : fexp

?fexp : [ fexp ] aexp

?aexp : qvar
      | literal
      | parexp
      | list
      | tuple
      | dict

?parexp  : "(" expression ")"
?literal : string | number
null     : NULL
qvar     : IDENTIFIER

list  : "[" [ [expression] ("," expression)* ] "]"
tuple : "(" [ expression ("," expression)+ ] ")"
dict  : "{" [ pair  ("," pair)*  ] "}"
pair  : expression ":" expression

string : ESCAPED_STRING
number : SIGNED_NUMBER

// Terminators (Lark terminators, that is)

NULL : "null"

IDENTIFIER : /[a-zA-Z_][a-zA-Z0-9_]*/

COMMENT : /#[^\n]*/


CR       : /\r/
LF       : /\n/
_NEWLINE : ( /\r?\n[\t ]*/ | COMMENT )+

%ignore COMMENT


// Ruby-style symbol data-type
SYMBOL : /:[a-zA-Z_][a-zA-Z0-9_]*/

// https ://github.com/lark-parser/lark/blob/master/lark/grammars/common.lark
%import common.ESCAPED_STRING
%import common.SIGNED_NUMBER

WS_INLINE : (" "|/\t/)+
WS        : /[ \t\f\r\n]/+

%ignore WS_INLINE

%declare _INDENT _DEDENT
