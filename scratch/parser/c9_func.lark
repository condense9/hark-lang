// ruby-doc.org/docs/ruby-doc-bundle/Manual/man-1.4/yacc.html
//
// Kinda like Ruby.
//
// Considerations
// - paradigm (functional)
// - assignment... ??
// - scope
// - easy of implementation
//
// Features
// - easy FFI (import a Python module and call functions in it)
// - ? lambdas (objects that can be evaluated with arguments substituted in)
// - function definition (named lambda expressions)
// - handle JSON-like data
// - ? closures (lambdas that capture lexical scope)
//
// Syntax must support
// - function definition
// - value binding (in a given scope, this is just an anonymous lambda application)
// - ? async/await
//
// Design decisions
// - variables are immutable (no reassignment, so line-order is irrelevant)
// - functions are pure
// - side-effects achieved through foreign calls (or built-in specials)


// https ://www.haskell.org/onlinereport/syntax-iso.html
// https ://wiki.haskell.org/Foreign_Function_Interface

?start : exp

?service     : "service" service_name [_NEWLINE body]
             | body
service_name : IDENTIFIER
?body        : [topform] (_NEWLINE topform)*
topform      : decl
             | import

import      : "import" import_name
import_name : IDENTIFIER

decl     : def_lhs "=" def_rhs
def_rhs  : exp
def_lhs  : def_name [binding*]
def_name : IDENTIFIER
binding  : IDENTIFIER


// fn         : "def" name "(" arglist ")" ":" _NEWLINE (assignments)* return_expr
// assignment : def_names "=" expressions _NEWLINE

?exp : exp_0

// homepage.divms.uiowa.edu/~fleck/HaskellexprBNF.pdf
// www.haskell.org/onlinereport/decls.html#fixity
//
// TODO - generate this from a table
// exp.0  : nexp.0 | lexp.0 | rexp.0
// nexp.0 : exp.1 [qop_n.0 exp.1]
// lexp.0 : (lexp.0 | exp.1) qop_l.0 | exp.1
// rexp.0 : exp.1 qop_r.0 (rexp.0 | exp.1)

?exp_0 : exp_1 [qop_n_0 exp_1]

?exp_1  : exp_2 | lexp_1
?lexp_1 : (lexp_1 | exp_2) qop_l_1 exp_2

?exp_2  : exp_top | lexp_2
?lexp_2 : (lexp_2 | exp_top) qop_l_2 exp_top

qop_n_0    : "<"  -> lt
           | ">"  -> gt
           | "==" -> eq
qop_l_1    : "+"  -> add
           | "-"  -> subtract
qop_l_2    : "*"  -> mutiply
           | "/"  -> divide
// qop_r_9 : "."  -> compose


// "then" is required to resolve ambiguity - function application is whitespace
?exp_top : fexp
         | "let" decls "in" block            -> let
         | "if" exp block "else" block  -> cond
         | "lambda" [binding*] block         -> lambda
         | "do" block

// block introduces lexical scope and returns a single value
block       : ":" (exp_block | _exp_list)
_exp_list   : exp (";" exp)*
?exp_block  : _NEWLINE _INDENT _block_item+ _DEDENT
_block_item : exp _NEWLINE
            | _exp_list _NEWLINE

decls       : let_binding
            | let_binding _NEWLINE _INDENT let_binding _NEWLINE _DEDENT
let_binding : name "=" value
name        : IDENTIFIER
value       : exp


?fexp : [ fexp ] aexp

// atomic expression
?aexp : qvar
      | literal
      | parexp
      | list
      | tuple
      | dict

arguments : exp*
?parexp   : "(" exp ")"
?literal  : string | number | bool | null
bool      : "true"  -> true
          | "false" -> false
null      : NULL
qvar      : IDENTIFIER


list  : "[" [ [exp] ("," exp)* ] "]"
tuple : "(" [ exp ("," exp)+ ] ")"
dict  : "{" [ pair  ("," pair)*  ] "}"
pair  : exp "=>" exp

string : ESCAPED_STRING
number : SIGNED_NUMBER


// Terminators (Lark terminators, that is)

NULL : "null"

IDENTIFIER : /[a-zA-Z_][a-zA-Z0-9_]*/

COMMENT : /#[^\n]*/

SEMICOLON : ";"

CR       : /\r/
LF       : /\n/
_NEWLINE : ( /\r?\n[\t ]*/ | COMMENT )+

%ignore COMMENT


// Ruby-style symbol data-type
SYMBOL : /:[a-zA-Z_][a-zA-Z0-9_]*/

// https ://github.com/lark-parser/lark/blob/master/lark/grammars/common.lark
%import common.ESCAPED_STRING
%import common.SIGNED_NUMBER

WS_INLINE : (" "|/\t/)+
WS        : /[ \t\f\r\n]/+

%ignore WS_INLINE

%declare _INDENT _DEDENT
